package com.forsyth.novm

import androidx.activity.compose.LocalActivity
import androidx.compose.runtime.Composable
import androidx.compose.runtime.RememberObserver
import androidx.compose.runtime.SideEffect
import androidx.compose.runtime.currentCompositeKeyHash
import androidx.compose.runtime.remember


/**
 * Mirrors [androidx.compose.runtime.saveable.rememberSaveable], but for non config state
 */
@Composable
fun <T: Any> retain(
    vararg inputs: Any?,
    across: StateDestroyingEvent = StateDestroyingEvent.PROCESS_DEATH,
    key: String? = null,
    init: () -> T
): T {

    val compositeKey = currentCompositeKeyHash
    // key is the one provided by the user or the one generated by the compose runtime
    val finalKey = if (!key.isNullOrEmpty()) {
        key
    } else {
        compositeKey.toString(MaxSupportedRadix)
    }

    // TODO static composition local of ComposeNonConfigStateRegistry?
    // research how components actually make it into LocalSaveableStateRegistryOwner
    // not sure how to bridge the gap b/t non-compose impl and compose impl. weird setup.
    val nonConfigRegistry = (LocalActivity.current as? StateSavingActivity)?.nonConfigStateRegistry

    val holder = remember {
        // value is restored using the registry or created via [init] lambda
        val restored = nonConfigRegistry?.consumeRestoredStateForKey(finalKey)
        val finalValue = restored ?: init()
        NonConfigHolder(null /* TODO composeregistry from registry*/, finalKey, finalValue, inputs)
    }

    val value = holder.getValueIfInputsDidntChange(inputs) ?: init()
    SideEffect {
        holder.update(null /* TODO composeregistry from registry */, finalKey, value, inputs)
    }
    @Suppress("UNCHECKED_CAST")
    return value as T
}

interface ComposeNonConfigStateRegistry {

    fun consumeRestored(key: String): Any?

    fun registerProvider(key: String, valueProvider: () -> Any?): Entry

    fun canBeSaved(value: Any): Boolean

    fun performSave(): Map<String, List<Any?>>

    interface Entry {
        fun unregister()
    }
}

private class NonConfigHolder<T>(
    private var registry: ComposeNonConfigStateRegistry?,
    private var key: String,
    private var value: T,
    private var inputs: Array<out Any?>
) : RememberObserver {
    private var entry: ComposeNonConfigStateRegistry.Entry? = null

    private val valueProvider = {
        requireNotNull(value) { "Value should be initialized" }
    }

    fun update(
        registry: ComposeNonConfigStateRegistry?,
        key: String,
        value: T,
        inputs: Array<out Any?>
    ) {
        var entryIsOutdated = false
        if (this.registry !== registry) {
            this.registry = registry
            entryIsOutdated = true
        }
        if (this.key != key) {
            this.key = key
            entryIsOutdated = true
        }
        this.value = value
        this.inputs = inputs
        if (entry != null && entryIsOutdated) {
            entry?.unregister()
            entry = null
            register()
        }
    }

    private fun register() {
        val registry = registry
        require(entry == null) { "entry($entry) is not null" }
        if (registry != null) {
            entry = registry.registerProvider(key, valueProvider)
        }
    }

    fun canBeSaved(value: Any): Boolean {
        return registry == null
    }

    override fun onRemembered() {
        register()
    }

    override fun onForgotten() {
        entry?.unregister()
    }

    override fun onAbandoned() {
        entry?.unregister()
    }

    fun getValueIfInputsDidntChange(inputs: Array<out Any?>): T? {
        return if (inputs.contentEquals(this.inputs)) {
            value
        } else {
            null
        }
    }
}

private const val MaxSupportedRadix = 36
