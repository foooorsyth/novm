package com.forsyth.novm.compose

import android.view.ViewGroup
import androidx.activity.compose.LocalActivity
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionContext
import androidx.compose.runtime.RememberObserver
import androidx.compose.runtime.SideEffect
import androidx.compose.runtime.currentCompositeKeyHash
import androidx.compose.runtime.remember
import androidx.compose.ui.platform.ComposeView
import androidx.lifecycle.findViewTreeLifecycleOwner
import androidx.lifecycle.findViewTreeViewModelStoreOwner
import androidx.lifecycle.setViewTreeLifecycleOwner
import androidx.lifecycle.setViewTreeViewModelStoreOwner
import androidx.savedstate.findViewTreeSavedStateRegistryOwner
import androidx.savedstate.setViewTreeSavedStateRegistryOwner
import com.forsyth.novm.StateDestroyingEvent
import com.forsyth.novm.StateSavingActivity


public fun StateSavingActivity.setContent(
    parent: CompositionContext? = null,
    content: @Composable () -> Unit
) {
    val existingComposeView =
        window.decorView.findViewById<ViewGroup>(android.R.id.content).getChildAt(0) as? ComposeView

    if (existingComposeView != null)
        with(existingComposeView) {
            setParentCompositionContext(parent)
            setContent(content)
        }
    else
        ComposeView(this).apply {
            // Set content and parent **before** setContentView
            // to have ComposeView create the composition on attach
            setParentCompositionContext(parent)
            setContent(content)
            // Set the view tree owners before setting the content view so that the inflation
            // process
            // and attach listeners will see them already present
            setOwners()
            setContentView(this, DefaultActivityContentLayoutParams)
        }
}

private fun StateSavingActivity.setOwners() {
    val decorView = window.decorView
    if (decorView.findViewTreeLifecycleOwner() == null) {
        decorView.setViewTreeLifecycleOwner(this)
    }
    if (decorView.findViewTreeViewModelStoreOwner() == null) {
        decorView.setViewTreeViewModelStoreOwner(this)
    }
    if (decorView.findViewTreeSavedStateRegistryOwner() == null) {
        decorView.setViewTreeSavedStateRegistryOwner(this)
    }
    // TODO findViewTreeNonConfigStateRegistryOwner
    // TODO setViewTreeNonConfigStateRegistryOwner
}

private val DefaultActivityContentLayoutParams =
    ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)

/**
 * Mirrors [androidx.compose.runtime.saveable.rememberSaveable], but for non config state
 */
@Composable
fun <T: Any> retain(
    vararg inputs: Any?,
    across: StateDestroyingEvent = StateDestroyingEvent.PROCESS_DEATH,
    key: String? = null,
    init: () -> T
): T {

    val compositeKey = currentCompositeKeyHash
    // key is the one provided by the user or the one generated by the compose runtime
    val finalKey = if (!key.isNullOrEmpty()) {
        key
    } else {
        compositeKey.toString(MaxSupportedRadix)
    }

    // TODO static composition local of ComposeNonConfigStateRegistry?
    // research how components actually make it into LocalSaveableStateRegistryOwner
    // not sure how to bridge the gap b/t non-compose impl and compose impl. weird setup.
    val nonConfigRegistry = (LocalActivity.current as? StateSavingActivity)?.nonConfigStateRegistry

    val holder = remember {
        // value is restored using the registry or created via [init] lambda
        val restored = nonConfigRegistry?.consumeRestoredStateForKey(finalKey)
        val finalValue = restored ?: init()
        ComposeNonConfigHolder(null /* TODO composeregistry from registry*/, finalKey, finalValue, inputs)
    }

    val value = holder.getValueIfInputsDidntChange(inputs) ?: init()
    SideEffect {
        holder.update(null /* TODO composeregistry from registry */, finalKey, value, inputs)
    }
    @Suppress("UNCHECKED_CAST")
    return value as T
}

interface ComposeNonConfigStateRegistry {

    fun consumeRestored(key: String): Any?

    fun registerProvider(key: String, valueProvider: () -> Any?): Entry

    fun performSave(): Map<String, List<Any?>>

    interface Entry {
        fun unregister()
    }
}

private class ComposeNonConfigHolder<T>(
    private var registry: ComposeNonConfigStateRegistry?,
    private var key: String,
    private var value: T,
    private var inputs: Array<out Any?>
) : RememberObserver {
    private var entry: ComposeNonConfigStateRegistry.Entry? = null

    private val valueProvider = {
        requireNotNull(value) { "Value should be initialized" }
    }

    fun update(
        registry: ComposeNonConfigStateRegistry?,
        key: String,
        value: T,
        inputs: Array<out Any?>
    ) {
        var entryIsOutdated = false
        if (this.registry !== registry) {
            this.registry = registry
            entryIsOutdated = true
        }
        if (this.key != key) {
            this.key = key
            entryIsOutdated = true
        }
        this.value = value
        this.inputs = inputs
        if (entry != null && entryIsOutdated) {
            entry?.unregister()
            entry = null
            register()
        }
    }

    private fun register() {
        val registry = registry
        require(entry == null) { "entry($entry) is not null" }
        if (registry != null) {
            entry = registry.registerProvider(key, valueProvider)
        }
    }

    override fun onRemembered() {
        register()
    }

    override fun onForgotten() {
        entry?.unregister()
    }

    override fun onAbandoned() {
        entry?.unregister()
    }

    fun getValueIfInputsDidntChange(inputs: Array<out Any?>): T? {
        return if (inputs.contentEquals(this.inputs)) {
            value
        } else {
            null
        }
    }
}

private const val MaxSupportedRadix = 36

// CharSequence.isBlank() allocates an iterator because it calls indices.all{}
private fun CharSequence.fastIsBlank(): Boolean {
    var blank = true
    for (i in 0 until length) {
        if (!this[i].isWhitespace()) {
            blank = false
            break
        }
    }
    return blank
}

private class ComposeNonConfigStateRegistryImpl(
    restored: Map<String, List<Any?>>?,
) : ComposeNonConfigStateRegistry {

    private val restored: MutableMap<String, List<Any?>> =
        restored?.toMutableMap() ?: mutableMapOf()
    private val valueProviders = mutableMapOf<String, MutableList<() -> Any?>>()

    override fun consumeRestored(key: String): Any? {
        val list = restored.remove(key)
        return if (list != null && list.isNotEmpty()) {
            if (list.size > 1) {
                restored[key] = list.subList(1, list.size)
            }
            list[0]
        } else {
            null
        }
    }

    override fun registerProvider(key: String, valueProvider: () -> Any?): ComposeNonConfigStateRegistry.Entry {
        require(!key.fastIsBlank()) { "Registered key is empty or blank" }
        @Suppress("UNCHECKED_CAST")
        valueProviders.getOrPut(key) { mutableListOf() }.add(valueProvider)
        return object : ComposeNonConfigStateRegistry.Entry {
            override fun unregister() {
                val list = valueProviders.remove(key)
                list?.remove(valueProvider)
                if (!list.isNullOrEmpty()) {
                    // if there are other providers for this key return list back to the map
                    valueProviders[key] = list
                }
            }
        }
    }

    override fun performSave(): Map<String, List<Any?>> {
        val map = restored.toMutableMap()
        valueProviders.forEach { (key, list) ->
            if (list.size == 1) {
                val value = list[0].invoke()
                if (value != null) {
                    map[key] = arrayListOf<Any?>(value)
                }
            } else {
                // if we have multiple providers we should store null values as well to preserve
                // the order in which providers were registered. say there were two providers.
                // the first provider returned null(nothing to save) and the second one returned
                // "1". when we will be restoring the first provider would restore null (it is the
                // same as to have nothing to restore) and the second one restore "1".
                map[key] = List(list.size) { index ->
                    val value = list[index].invoke()
                    //if (value != null) {
                        // TODO do we support null? we should, right?
                        //check(canBeSaved(value)) { generateCannotBeSavedErrorMessage(value) }
                    //}
                    value
                }
            }
        }
        return map
    }
}
