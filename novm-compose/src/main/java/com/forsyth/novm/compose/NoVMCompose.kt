package com.forsyth.novm.compose

import android.util.Log
import androidx.activity.compose.LocalActivity
import androidx.compose.runtime.Composable
import androidx.compose.runtime.RememberObserver
import androidx.compose.runtime.SideEffect
import androidx.compose.runtime.currentCompositeKeyHash
import androidx.compose.runtime.remember
import androidx.compose.ui.platform.LocalSavedStateRegistryOwner
import com.forsyth.novm.StateDestroyingEvent
import com.forsyth.novm.StateSavingActivity

/**
 *
 * Mirrors [androidx.compose.runtime.saveable.rememberSaveable], but for non config state
 */
@Composable
fun <T: Any> retain(
    vararg inputs: Any?,
    across: StateDestroyingEvent = StateDestroyingEvent.PROCESS_DEATH,
    key: String? = null,
    init: () -> T
): T {

    /*
     Their setup flow
     - in AndroidComposeView.android.kt (androidx.compose.ui), viewTreeOwners are set in #onAttachedToWindow
     - in AndroidCompositionLocal.android.kt (androidx.compose.ui), the composable function ProvideAndroidCompositionLocals
     provides viewTreeOwners.savedStateRegistry
        - note the DisposableSavedStateRegistry here -- we need to unregister
    -  ProvideAndroidCompositionLocals is called in WrappedComposition (Wrapper.android.kt, androidx.compose.ui)
    - WrappedComposition is used in doSetContent (same file), and doSetContent is called in AbstractComposeView.setContent
    - Then, this AbstractComposeView.setContent is called in the ComposeView.

     */
    Log.d("ComposeActivity", "is LNCSRO a SSA?: ${(LocalNonConfigStateRegistryOwner.current is StateSavingActivity)}")
    Log.d("ComposeActivity", "is LSSRO a SSA?: ${(LocalSavedStateRegistryOwner.current is StateSavingActivity)}")
    // Above both succeed. Good! we now have our composition local for LNCSRO
    // TODO setup composition local for ComposeNonConfigStateRegistry
    // TODO investigate "TODO MUST FIX ASAP" in NonConfigStateRegistry#consumeRestoredStateForKey

    val compositeKey = currentCompositeKeyHash
    // key is the one provided by the user or the one generated by the compose runtime
    val finalKey = if (!key.isNullOrEmpty()) {
        key
    } else {
        compositeKey.toString(MaxSupportedRadix)
    }

    // TODO static composition local of ComposeNonConfigStateRegistry?
    // research how components actually make it into LocalSaveableStateRegistryOwner
    // not sure how to bridge the gap b/t non-compose impl and compose impl. weird setup.
    val nonConfigRegistry = (LocalActivity.current as? StateSavingActivity)?.nonConfigStateRegistry

    val holder = remember {
        // value is restored using the registry or created via [init] lambda
        val restored = nonConfigRegistry?.consumeRestoredStateForKey(finalKey)
        val finalValue = restored ?: init()
        ComposeNonConfigHolder(null /* TODO composeregistry from registry*/, finalKey, finalValue, inputs)
    }

    val value = holder.getValueIfInputsDidntChange(inputs) ?: init()
    SideEffect {
        holder.update(null /* TODO composeregistry from registry */, finalKey, value, inputs)
    }
    @Suppress("UNCHECKED_CAST")
    return value as T
}

interface ComposeNonConfigStateRegistry {

    fun consumeRestored(key: String): Any?

    fun registerProvider(key: String, valueProvider: () -> Any?): Entry

    fun performSave(): Map<String, List<Any?>>

    interface Entry {
        fun unregister()
    }
}

private class ComposeNonConfigHolder<T>(
    private var registry: ComposeNonConfigStateRegistry?,
    private var key: String,
    private var value: T,
    private var inputs: Array<out Any?>
) : RememberObserver {
    private var entry: ComposeNonConfigStateRegistry.Entry? = null

    private val valueProvider = {
        requireNotNull(value) { "Value should be initialized" }
    }

    fun update(
        registry: ComposeNonConfigStateRegistry?,
        key: String,
        value: T,
        inputs: Array<out Any?>
    ) {
        var entryIsOutdated = false
        if (this.registry !== registry) {
            this.registry = registry
            entryIsOutdated = true
        }
        if (this.key != key) {
            this.key = key
            entryIsOutdated = true
        }
        this.value = value
        this.inputs = inputs
        if (entry != null && entryIsOutdated) {
            entry?.unregister()
            entry = null
            register()
        }
    }

    private fun register() {
        val registry = registry
        require(entry == null) { "entry($entry) is not null" }
        if (registry != null) {
            entry = registry.registerProvider(key, valueProvider)
        }
    }

    override fun onRemembered() {
        register()
    }

    override fun onForgotten() {
        entry?.unregister()
    }

    override fun onAbandoned() {
        entry?.unregister()
    }

    fun getValueIfInputsDidntChange(inputs: Array<out Any?>): T? {
        return if (inputs.contentEquals(this.inputs)) {
            value
        } else {
            null
        }
    }
}

private const val MaxSupportedRadix = 36

// CharSequence.isBlank() allocates an iterator because it calls indices.all{}
private fun CharSequence.fastIsBlank(): Boolean {
    var blank = true
    for (i in 0 until length) {
        if (!this[i].isWhitespace()) {
            blank = false
            break
        }
    }
    return blank
}

class ComposeNonConfigStateRegistryImpl(
    restored: Map<String, List<Any?>>?,
) : ComposeNonConfigStateRegistry {

    private val restored: MutableMap<String, List<Any?>> =
        restored?.toMutableMap() ?: mutableMapOf()
    private val valueProviders = mutableMapOf<String, MutableList<() -> Any?>>()

    override fun consumeRestored(key: String): Any? {
        val list = restored.remove(key)
        return if (list != null && list.isNotEmpty()) {
            if (list.size > 1) {
                restored[key] = list.subList(1, list.size)
            }
            list[0]
        } else {
            null
        }
    }

    override fun registerProvider(key: String, valueProvider: () -> Any?): ComposeNonConfigStateRegistry.Entry {
        require(!key.fastIsBlank()) { "Registered key is empty or blank" }
        @Suppress("UNCHECKED_CAST")
        valueProviders.getOrPut(key) { mutableListOf() }.add(valueProvider)
        return object : ComposeNonConfigStateRegistry.Entry {
            override fun unregister() {
                val list = valueProviders.remove(key)
                list?.remove(valueProvider)
                if (!list.isNullOrEmpty()) {
                    // if there are other providers for this key return list back to the map
                    valueProviders[key] = list
                }
            }
        }
    }

    override fun performSave(): Map<String, List<Any?>> {
        val map = restored.toMutableMap()
        valueProviders.forEach { (key, list) ->
            if (list.size == 1) {
                val value = list[0].invoke()
                if (value != null) {
                    map[key] = arrayListOf<Any?>(value)
                }
            } else {
                // if we have multiple providers we should store null values as well to preserve
                // the order in which providers were registered. say there were two providers.
                // the first provider returned null(nothing to save) and the second one returned
                // "1". when we will be restoring the first provider would restore null (it is the
                // same as to have nothing to restore) and the second one restore "1".
                map[key] = List(list.size) { index ->
                    val value = list[index].invoke()
                    //if (value != null) {
                        // TODO do we support null? we should, right?
                        //check(canBeSaved(value)) { generateCannotBeSavedErrorMessage(value) }
                    //}
                    value
                }
            }
        }
        return map
    }
}
